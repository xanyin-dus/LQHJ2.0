# LQHJ2.0 - 灵棋幻境 `arch` 分支
<div align="center">
    <img src="https://img.shields.io/badge/Qt6.8-blue.svg" alt="Qt Version">
    <img src="https://img.shields.io/badge/Language-C%2B%2B11%2B%2FQML-orange.svg" alt="Development Language">
    <img src="https://img.shields.io/badge/Build-CMake-green.svg" alt="Build Tool">
    <img src="https://img.shields.io/badge/Version%20Control-Git-red.svg" alt="Version Control">
    <p>基于Qt QML+C++混合开发的分层架构五子棋游戏，融合轻量剧情分支，支持模块化协同开发</p>
</div>

---

## 🎯 项目简介
LQHJ2.0 是一款基于**Qt QML + C++** 混合开发的跨平台五子棋游戏，核心特色是在经典五子棋玩法基础上融入**轻量剧情分支**，采用**表现层与业务逻辑层解耦**的分层架构设计，兼顾游戏交互体验与剧情叙事性，支持多端编译运行。

> ⚠️ **重要提示**
> 本`arch`分支为项目**核心架构基准分支**，定义了统一的目录结构、代码规范与模块分工，是所有开发组员的基础开发分支。**仅维护架构、通用组件与工具函数，禁止所有组员直接在该分支开发/提交业务功能代码**，新功能需基于本分支创建功能分支开发。

### ✨ 架构特性
- 🧩 QML（表现层）+ C++（逻辑层）经典混合开发，UI与业务逻辑完全解耦，便于团队分工迭代
- ♟️ 实现五子棋核心逻辑：棋盘状态管理、落子校验、横竖斜向胜负判断、人机对战基础框架
- 📖 内置轻量剧情系统，支持JSON格式剧情文本加载、多分支选择、游戏玩法与剧情联动触发
- 📦 完善的资源管理体系，实现图片/音频/剧情文本的统一加载、缓存与释放，避免资源重复加载
- 🔧 封装通用可复用UI组件库，降低界面开发成本，保证全项目UI风格与交互逻辑统一
- 💾 支持游戏进度/剧情进度本地存档、棋盘大小/音量等个性化设置的持久化
- 🧪 内置单元测试用例，覆盖棋盘核心逻辑，保障基础功能稳定性，支持后续回归测试

## 🛠️ 技术栈
| 分类         | 技术选型&版本要求                                                                 |
|--------------|----------------------------------------------------------------------------------|
| 核心框架     | Qt 6.8（需包含QML/Qt Quick模块）|
| 开发语言     | QML（界面渲染/交互）、C++11+（业务逻辑/数据处理）|
| 构建工具     | CMake 3.16+（跨平台统一编译配置，兼容Qt Creator/命令行）|
| 数据格式     | JSON（剧情文本存储、存档数据序列化，便于编辑与解析）|
| 资源管理     | Qt资源系统（qrc），实现静态资源打包与全局统一访问                                |
| 测试框架     | Qt Test（C++单元测试，针对核心逻辑模块做功能验证）|
| 版本控制     | Git（`arch`为架构基准分支，基于功能分支做协同开发）|
| 编译器       | Windows(MSVC2019+/MinGW)、Linux(GCC)、macOS(Clang)                                |

## 📁 项目架构
项目严格遵循**分层设计**与**模块化开发**原则，目录结构高内聚低耦合，各模块职责单一，所有目录/文件的命名与用途均做统一约定，开发时需严格遵循以保证项目一致性。

### 完整目录结构
```
LQHJ20/
├── CMakeLists.txt          # 项目全局CMake构建配置，管理Qt依赖/编译/链接规则
├── qml.qrc                 # Qt资源注册文件，所有静态资源需在此注册后全局访问
├── res/                    # 静态资源根目录，按资源类型分类存放，统一管理
│   ├── images/             # 图片资源：棋盘、棋子、背景、按钮、剧情插图等
│   ├── audio/              # 音频资源：背景音乐、落子音效、剧情配音、按钮交互音效等
│   └── story/              # 剧情资源：JSON格式章节文本、剧情触发条件配置等
├── qml/                    # QML表现层，仅负责UI/交互/动画，无任何业务逻辑
│   ├── Main.qml            # QML入口，主窗口布局，管理全局界面栈与页面切换
│   ├── views/              # 业务界面目录，单个功能独立为QML文件，便于维护
│   │   ├── MainMenuView.qml    # 主菜单：游戏开始、剧情入口、设置、退出等
│   │   ├── GameView.qml        # 核心游戏界面：棋盘渲染、棋子落子、回合提示、胜负弹窗等
│   │   ├── StoryView.qml       # 剧情界面：文本滚动、分支选项、背景动画、剧情跳转等
│   │   └── SettingsView.qml    # 设置界面：音量调节、棋盘大小、存档管理、关于等
│   └── components/         # 通用UI组件库，全项目共享，无业务耦合，可直接复用
│       ├── ChessPiece.qml      # 棋子组件：封装黑白棋样式、落子动画、选中效果等
│       ├── CustomButton.qml    # 自定义按钮：统一项目按钮样式、点击效果、文字排版等
│       └── Dialog.qml          # 通用弹窗：封装提示/确认/错误弹窗，支持自定义内容
├── src/                    # C++逻辑层，与QML完全解耦，提供清晰接口供上层调用
│   ├── main.cpp            # C++程序入口，初始化Qt应用、加载QML、注册C++类到QML上下文
│   ├── game/               # 五子棋核心逻辑模块，游戏玩法的核心实现
│   │   ├── Board.h/.cpp        # 棋盘数据层：管理棋盘状态、落子坐标、棋子数据，提供落子/悔棋接口
│   │   ├── GameController.h/.cpp  # 游戏控制层：流程管理、落子校验、横竖斜向胜负判断
│   │   └── Player.h/.cpp       # 玩家模型：封装名称、棋子颜色、人机/人类标识、胜率等信息
│   ├── story/              # 剧情系统模块，负责剧情的加载、解析、分支与联动
│   │   ├── StoryManager.h/.cpp    # 剧情管理核心：JSON加载、进度管理、分支选择、剧情事件触发
│   │   └── StoryChapter.h/.cpp    # 剧情章节模型：封装文本、选项、背景、触发条件、下一章关联等
│   ├── data/               # 数据管理模块，负责存档与资源的全局管理
│   │   ├── SaveManager.h/.cpp     # 存档管理：游戏/剧情进度的序列化/反序列化、本地文件存储
│   │   └── ResourceManager.h/.cpp # 资源管理：图片/音频的统一加载、缓存、释放，避免重复加载
│   ├── app/                # 应用全局控制模块，负责界面切换、全局状态与模块通信
│   │   └── AppController.h/.cpp   # 全局控制器：界面栈管理、模块间信号转发、全局异常捕获与提示
│   └── utils/              # 通用工具模块，提供全项目共享的常量与工具函数
│       ├── Constants.h           # 全局常量：棋盘大小、胜利条件、资源路径、配置项键名等
│       └── Utils.h/.cpp          # 工具函数：坐标转换、JSON解析、日志输出、字符串处理等
└── tests/                  # 单元测试目录，基于Qt Test实现，覆盖核心逻辑模块
    └── BoardTest.cpp       # 棋盘逻辑测试：验证落子校验、胜负判断、棋盘状态管理等核心功能
```

### 分层设计说明
项目分为四层设计，层与层之间通过**Qt信号与槽**通信，无直接耦合，保证各层的独立性与可维护性：
1. **🎨 表现层（qml/）**：仅负责UI渲染、用户交互、动画效果，不处理任何业务逻辑，通过信号将用户操作传递给C++逻辑层
2. **🧠 逻辑层（src/）**：项目核心，实现所有业务逻辑、数据处理、资源管理，对外提供清晰的调用接口，不依赖任何QML组件
3. **📦 资源层（res/）**：所有静态资源的统一存储目录，通过`qml.qrc`注册后，可在QML和C++中通过统一路径访问
4. **🧪 测试层（tests/）**：针对核心逻辑模块编写单元测试用例，保障基础功能的正确性，新功能开发后需补充对应测试

## 💻 环境搭建与项目运行
### 前置环境要求
1. 安装6.8（**必须包含**QML、Qt Quick、Qt Core、Qt Gui、Qt Test模块，推荐使用Qt Online Installer）
2. 安装CMake 3.16+（可通过Qt Maintenance Tool安装，或单独下载配置环境变量）
3. 安装对应平台的C++编译器（Windows：MSVC2019+/MinGW；Linux：GCC；macOS：Clang）
4. 克隆仓库并切换至`arch`分支：
```bash
# 克隆仓库
git clone https://github.com/xanyin-dus/LQHJ2.0.git LQHJ20
# 进入项目根目录
cd LQHJ20
# 切换至架构基准分支
git checkout arch
```

### 编译与运行步骤
#### 方式1：Qt Creator（推荐，可视化操作，适合开发调试）
1. 打开Qt Creator，选择「打开文件或项目」，选中项目根目录的`CMakeLists.txt`
2. 自动加载CMake配置，选择对应Qt版本与编译器，点击「配置项目」
3. 点击**构建**（锤子图标）完成编译，点击**运行**（三角图标）启动项目

#### 方式2：命令行（CMake，跨平台，适合持续集成/无图形化环境）
```bash
# 进入项目根目录
cd LQHJ20
# 创建构建目录（源码与构建文件分离，推荐）
mkdir build && cd build
# CMake配置（若Qt已配置环境变量，可省略-DCMAKE_PREFIX_PATH）
cmake .. -DCMAKE_PREFIX_PATH=<你的Qt安装路径>/cmake
# 编译项目（-j后接数字为编译线程数，根据电脑配置调整，如-j4/-j8）
cmake --build . -j4
# 运行项目
# Windows：build/Debug/ 或 build/Release/ 目录下执行
./Debug/LQHJ20.exe
# Linux/macOS：直接在build目录下执行
./LQHJ20
```

## 📜 开发规范
为保证团队协同开发效率与项目可维护性，**所有组员必须严格遵循以下规范**，新功能开发需基于`arch`分支创建功能分支，禁止直接修改`arch`分支代码。

### 1. 🌿 分支管理规范
| 分支类型   | 命名规范               | 用途说明&权限                                                                 |
|------------|------------------------|------------------------------------------------------------------------------|
| `arch`     | 基准分支               | 核心架构分支，仅项目负责人维护，**禁止所有组员直接push/提交/修改**             |
| 功能分支   | `feature/模块-功能`    | 基于arch创建，开发新功能（例：`feature/game-ai`、`feature/story-chapter1`）|
| 修复分支   | `fix/模块-问题描述`    | 基于arch创建，修复bug（例：`fix/board-wincheck`、`fix/qml-storyscroll`）|

**核心规则**：
- 功能开发完成并自测通过后，向`arch`分支发起**合并请求（PR）**，审核通过后方可合并
- 开发过程中需**定期同步**`arch`最新代码，避免冲突：
  ```bash
  git checkout arch && git pull origin arch && git checkout 你的分支 && git merge arch
  ```

### 2. 📂 目录开发规范
1. **res/**：新增资源必须放入对应子目录，文件命名采用**小写+下划线**（例：`black_chess.png`、`story_chapter1.json`）
2. **qml/views/**：新增业务界面必须放入此目录，命名**大驼峰+View**（例：`RankView.qml`）
3. **qml/components/**：新增通用组件必须放入此目录，命名**大驼峰**（例：`Loading.qml`）
4. **src/**：新增模块需创建对应子目录，C++类采用**头文件+源文件**分离，命名**大驼峰**
5. **tests/**：新增核心逻辑后，可以补充对应测试文件，命名**模块+Test.cpp**（例：`AITest.cpp`）
6. 所有QML内的属性/组件、C++的函数/变量，命名需遵循下文**代码命名规范**

### 3. ✍️ 代码命名与编写规范
#### 通用规则
- 所有代码缩进为**4个空格**
- QML/C++均需添加**必要注释**，核心逻辑、接口、自定义属性必须写注释，保证可读性
- 避免冗余代码，通用逻辑/组件需抽离到工具类/通用组件库，禁止重复实现

#### 命名规范表
| 代码类型                | 命名规则               | 示例                                                                 |
|-------------------------|------------------------|----------------------------------------------------------------------|
| QML文件（视图/组件）| 大驼峰                 | GameView.qml、ChessPiece.qml                                         |
| QML属性/信号/函数       | 小驼峰                 | chessSize、onDropChess、showTip()                                     |
| C++文件（h/cpp）| 大驼峰                 | GameController.h、SaveManager.cpp                                     |
| C++类成员变量           | 小驼峰+下划线结尾      | boardSize_、currentPlayer_                                           |
| C++成员函数/全局函数    | 小驼峰                 | checkWin()、loadStory()、convertCoordinate()                          |
| C++全局常量/宏          | 大写+下划线            | MAX_BOARD_SIZE、WIN_CONDITION、RESOURCE_PATH                          |
| 静态资源文件            | 小写+下划线            | white_chess.png、drop_chess.wav、story_chapter2.json                  |

#### QML专属规范
- 避免在QML中编写复杂业务逻辑，仅处理UI交互/动画，复杂逻辑通过信号传递给C++
- 通用组件需封装清晰的**property/signal/function**，禁止耦合业务逻辑
- 组件属性按**布局→样式→交互→自定义**分类排列，提升代码可读性

#### C++规范
1. 头文件必须添加**头文件保护**，格式为`LQHJ20_模块_类名_H`：
   ```cpp
   #ifndef LQHJ20_GAME_BOARD_H
   #define LQHJ20_GAME_BOARD_H
   // 头文件内容
   #endif // LQHJ20_GAME_BOARD_H
   ```
2. 与QML交互的类必须添加`Q_OBJECT`宏，属性用`Q_PROPERTY`声明，信号/槽按Qt规范定义
3. 所有C++类需放入**对应模块的命名空间**（例：game::Board、story::StoryManager），避免命名冲突
4. 头文件仅做声明，禁止定义全局变量/函数，实现代码全部放入cpp文件
5. 通用工具函数/常量统一放入`src/utils/`，禁止各模块重复定义

### 4. 📝 Git提交规范
Commit信息需**清晰、简洁、标准化**，便于追溯代码变更，格式为：`[类型] 模块：简短描述`（不超过50字）
| 提交类型   | 说明                     | 示例                                          |
|------------|--------------------------|-----------------------------------------------|
| `feat`     | 新增功能                 | `[feat] game：实现人机落子基础逻辑`|
| `fix`      | 修复bug                  | `[fix] board：修复横排胜负判断漏判问题`|
| `refactor` | 代码重构（无功能变更）| `[refactor] utils：优化坐标转换函数`|
| `style`    | 代码样式调整（无功能变更）| `[style] qml：统一按钮组件样式`|
| `docs`     | 文档更新                 | `[docs] README：补充模块职责说明`|
| `test`     | 新增/修改测试用例        | `[test] board：添加落子校验测试用例`|
| `chore`    | 构建/资源文件变更        | `[chore] qrc：添加棋子图片与落子音效`|

**提交示例**：
```bash
git commit -m "[feat] story：加载chapter1的JSON剧情并实现文本滚动"
git commit -m "[fix] qml：修复StoryView分支选项点击无响应问题"
git commit -m "[docs] README：完善开发规范中的命名规则"
```

## 👥 模块职责划分
项目按功能模块分工，各模块之间通过**接口/信号与槽**通信，**禁止直接跨模块调用私有成员**，保证模块独立性。以下为核心模块的职责与协作点，便于团队分工开发：

| 开发小组       | 负责目录                  | 核心开发职责                                                                 | 核心协作点                                                                 |
|----------------|---------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **游戏核心组** | `src/game/`               | 五子棋核心逻辑：棋盘管理、落子校验、胜负判断、人机AI、回合/悔棋逻辑            | 与AppController交互控制游戏流程，与GameView.qml交互实现棋盘渲染            |
| **剧情开发组** | `src/story/` + `res/story/` | 剧情系统开发、JSON剧情编写、分支处理、剧情与游戏的联动触发、StoryView开发      | 与SaveManager交互存档剧情进度，与GameController联动游戏剧情触发条件        |
| **数据管理组** | `src/data/`               | 资源统一加载/缓存/释放、游戏/剧情进度的序列化、本地存档与读取                  | 为所有模块提供资源访问接口，为游戏/剧情组提供存档接口                      |
| **应用控制组** | `src/app/` + `qml/Main.qml` | 全局界面栈管理、模块间信号转发、全局状态管理、全局异常捕获与提示              | 作为项目中枢，与所有模块交互，协调各模块工作                                |
| **UI/交互组**  | `qml/`（除Main.qml）| 所有业务界面开发、通用组件封装、交互效果与动画优化、UI风格统一                | 与AppController交互实现界面切换，与游戏/剧情组通过信号处理用户操作          |
| **工具/测试组** | `src/utils/` + `tests/`   | 通用工具函数/全局常量开发、核心逻辑单元测试、测试用例维护与回归测试            | 为所有模块提供工具支持，对核心模块的修改做回归测试，保障功能稳定            |

## 🔧 `arch`分支维护说明
1. 📌 本分支为**稳定架构基准**，仅包含基础架构、通用组件、工具函数，无任何业务功能代码
2. 🔒 仅项目负责人拥有修改/合并权限，所有组员**禁止直接push/提交**任何代码到本分支
3. 🏗️ 若需调整架构（新增模块、修改目录、变更核心接口），需组织团队讨论达成一致后，由负责人统一修改
4. ⚖️ 组员合并功能分支到本分支时，若出现代码冲突，需**自行解决冲突**后再发起PR
5. 🔖 架构调整/组件优化完成后，负责人会对本分支做**版本标记**（如`v0.1-arch`），便于追溯架构版本

## 🚀 后续开发计划
基于`arch`分支的基础架构，按**功能模块分阶段**开发，优先实现核心玩法，再逐步完善剧情、UI与优化体验，各阶段核心目标如下：
1. **第一阶段：主要玩法** - 完善五子棋核心逻辑，实现基础人机AI，开发主菜单与游戏界面，实现无剧情的基础五子棋玩法
2. **第二阶段：剧情系统** - 完成剧情系统核心功能开发，编写第一章剧情文本，实现剧情与游戏的简单联动，开发剧情展示界面
3. **第三阶段：基础功能** - 实现游戏/剧情进度存档功能，开发设置界面（音量/棋盘大小/存档管理），完善资源加载体系
4. **第四阶段：体验优化** - 优化人机AI难度分级，增加更多剧情章节与分支，补充音频/图片资源，优化UI交互与动画效果
5. **第五阶段：测试发布** - 全项目回归测试、bug修复，代码结构与性能优化，完善项目文档，发布项目正式版本

## 🤝 贡献指南
1. 所有开发组员需先克隆仓库并切换至`arch`分支，基于本分支创建个人功能分支
2. 开发过程中严格遵循本文档的**开发规范**，保证代码风格与项目一致性
3. 功能开发完成后，需进行**自测**（功能测试+单元测试），确保功能正常、无bug
4. 自测通过后，向`arch`分支发起**合并请求（PR）**，并在PR中说明功能实现、修改点与测试情况
5. PR审核通过后，负责人合并代码，组员可基于最新的`arch`分支开发下一个功能
6. 开发中遇到问题，可在项目仓库发起**Issue**，描述问题现象、复现步骤与环境信息，便于团队共同解决

## 🙏 致谢
感谢所有开发组员的参与与贡献，本项目的开发基于Qt官方文档、五子棋经典算法与开源项目的技术参考，在此表示诚挚的感谢。
